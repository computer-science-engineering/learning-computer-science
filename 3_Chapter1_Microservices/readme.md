# Chapter 1: Microservices

1. Domain-driven design: Eric Evans’s book Domain-Driven Design (Addison-Wesley) helped us understand the importance of representing the real world in our code, and showed us better ways to model our systems.
2. Continuous delivery: The concept of continuous delivery showed how we can more effectively and efficiently get our software into production, instilling in us the idea that we should treat every check-in as a release candidate.
3. Our understanding of how the Web works has led us to develop better ways of having machines talk to other machines.
4. Alistair Cockburn’s concept of hexagonal architecture guided us away from layered architectures where business logic could hide.
5. On-demand virtualization: Virtualization platforms allowed us to provision and resize our machines at will, with infrastructure automation giving us a way to handle these machines at scale.
6. Small autonomous teams: Some large, successful organizations like Amazon and Google espoused the view of small teams owning the full lifecycle of their services.
7. Systems at scale: And, more recently, Netflix has shared with us ways of building antifragile systems at a scale that would have been hard to comprehend just 10 years ago.

Microservices have emerged from this world. They weren’t invented or described before the fact; they emerged as a trend, or a pattern, from real-world use. But they exist only because of all that has gone before. Throughout this book, I will pull strands out of this  work to help paint a picture of how to build, manage, and evolve microservices.

Many organizations have found that by embracing fine-grained, microservice architectures, they can deliver software faster and embrace newer technologies. Microservices give us significantly more freedom to react and make different decisions, allowing us to respond faster to the inevitable change that impacts all of us.